---
layout: post
title: "docopt: A brief introduction"
description: "The biggest advancement of argument parsing in the last 40 years"
cover: keyboard.jpg
comments: true
categories:
- Software
tags:
- docopt
- argument parsing
- ruby
- python
---

Making command-line applications always starts the same way: by looking up the
documentation for the option parser. It's been over 40 years since the first
CLI program was written so these parsing libraries tend to be quite clever
these days. They will do most of the work for you and generate a useful help
message too. The code may not always be very elegant, but it works. So if the
nice-looking help messages can be generated from the not-so-lovely parser code,
couldn't it be done the other way around? Well, YES, it could!

**docopt** is a _language_ for describing command line interfaces based on the
notation that is commonly used in help messages to explain the subcommands,
options and arguments of applications. Most importantly though, **docopt** is a
brilliant idea. An implementation of the **docopt** language will read your
specification and generate an argument parser based on it. The parser will then
process the argument string and return a dictionary with the results.

Pioneered by [Vladimir Keleshev](https://twitter.com/keleshev) in 2012 for
Python, the idea caught on rather quickly and people started making **docopt**
available for other programming languages as well. There are now many
implementations available in languages including C, Go, Java, Ruby,
CoffeScript, Rust, and PHP. See the complete list of all the officially
supported ones on [Github](https://github.com/docopt).

## The language

The description language is a _formalised_ version of the common help messages
as you may know them from existing applications. Despite its simplicity, the
syntax very powerful with all the features you might expect from a reasonable
argument parser. It supports subcommands, options and positional arguments. Any
of these can be made either optional or mandatory, and also mutually exclusive
with other options or arguments. Option arguments can have default values
assigned. And it is also possible to have a variable number of positional
arguments, e.g., zero or more of them. Here's an example of a program
description using **docopt**:

{% highlight text %}
Build and release software packages.

Usage:
  pkg add <repository> [--branch=<b>]
  pkg build <name>... [--force] [--env=<env>]
  pkg push <name> [<suite>] [--force]
  pkg clean (builds|cache)
  pkg -h | --help
  pkg --version

Options:
  -h, --help        Print this.
  -b, --branch=<b>  Git branch name [default: master].
  -f, --force       Perform the operation despite warnings.
  -e, --env=<e>     Select build environment [default: wheezy].
{% endhighlight %}

This is almost identical with the help description generated by Ruby's
`OptionParser` or Python's `ArgumentParser`.

## Parsing the command line

Now that the description is ready, how do we get from that to actually
processing the arguments of your program? You'll be pleased to hear that this
step is even simpler. The API consists of a **single function** that expects to
receive the command-line string and returns a dictionary with all the options
and arguments. It may differ slightly between implementations though.

I've tried the Python, Ruby and CoffeScript/JS versions and they worked really
well. Using the same options description in all of them wasn't a problem at
all. A few pointers and an example of how it works in each of the languages
follows.

### Python

**docopt** is available as a [package](https://pypi.python.org/pypi/docopt) in
the Python Package Index, so you can install it using the following command:

{% highlight bash %}
sudo pip install docopt
{% endhighlight %}

[PEP 257](https://www.python.org/dev/peps/pep-0257/) recommends that the
docstring of a script corresponds with its 'usage' message. We'll put the
**docopt** spec in there, right at the beginning of our script and refer to
it through the `__doc__` special variable. The `docopt` function will read
`sys.argv` parse it. If we pass the version of our program to the function
as wel, it will create the `--version` option automatically.

{% highlight python %}
#!/usr/bin/env python

"""
Example program.

Usage:
  example command [<cmd_arg>]...
  example [-br] -p=<opt_arg> <argument>
  example -h | --help
  example --version

 Options:
   -h, --help       Show this message.
   -b, --beer       Drink beer.
   -r, --rock       Play AC/DC.
   -p, --pub=<p>    Which pub.
   --version        Print the version.
"""

from docopt import docopt
from pprint import pprint

if __name__ == '__main__':
    arguments = docopt(__doc__, version='FIXME')
    pprint(arguments)
{% endhighlight %}

### Ruby

Similarly for Ruby, there is a [docopt gem](https://rubygems.org/gems/docopt).
Use the following command to install it:

{% highlight bash %}
sudo gem install docopt
{% endhighlight %}

The interface in Ruby is much the same as in Python.

{% highlight ruby %}
#!/usr/bin/env ruby

require 'docopt'
require 'pp'

doc = <<DOCOPT
Example program.

Usage:
  example command [<cmd_arg>]...
  example [-br] -p=<opt_arg> <argument>
  example -h | --help
  example --version

 Options:
   -h, --help       Show this message.
   -b, --beer       Drink beer.
   -r, --rock       Play AC/DC.
   -p, --pub=<p>    Which pub.
   --version        Print the version.
DOCOPT

begin
  pp Docopt::docopt(doc, version: '1.2.3')
rescue Docopt::Exit => e
  puts e.message
end
{% endhighlight %}

### CoffeeScript

You can use [npm](https://www.npmjs.com/) to get **docopt** for Coffee/JS.
The following command will install it globally on your system:

{% highlight bash %}
sudo npm install -g docopt
{% endhighlight %}

And again, the interface is almost identical with the

{% highlight coffee %}
doc = """
Example program.

Usage:
  example command [<cmd_arg>]...
  example [-br] -p=<opt_arg> <argument>
  example -h | --help
  example --version

 Options:
   -h, --help       Show this message.
   -b, --beer       Drink beer.
   -r, --rock       Play AC/DC.
   -p, --pub=<p>    Which pub.
   --version        Print the version.
"""
{docopt} = require 'docopt'

console.log docopt(doc, version: '1.2.3')
{% endhighlight %}

## Summary

Docopt is a delightful way of describing command line interfaces. It means you
can skip the ritual of looking up the documentation and implementing the parser
before you get to the interesting part. Was that `add_argument()` or
`addArgument()`? Who remembers these things? It's free and open-source,
[available on Github](https://github.com/docopt) for many different languages.
Give it a go :-)!
