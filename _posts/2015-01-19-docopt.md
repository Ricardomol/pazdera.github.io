---
layout: post
title: "docopt: A brief introduction"
description: "The biggest advancement in argument parsing in the last 40 years"
cover: keyboard.jpg
comments: true
categories:
- Software
tags:
- docopt
- argument parsing
- ruby
- python
- CoffeeScript
---

Making a command-line application always starts by either looking up the
documentation for the option parser or copying it from an app you made before.
It's been well over 40 years since the first CLI programs were made so these
parsing libraries tend to be pretty clever these days. They will do most of
the work for you and generate a useful help message too. The code may not
always be elegant, but it works. So if the nice-looking help messages can be
generated from the not-so-lovely parser code, couldn't it be done the other
way around? Well, YES, it could!

**docopt** is a _declarative language_ for describing command line interfaces.
It's based on the notation that is commonly used in **help messages** to explain
the subcommands, options and arguments of programs. Most importantly though,
**docopt** is a brilliant idea. It cuts down the boilerplate to the bare minimum,
letting you move on to the the reason why you are making the app in the first
place. An implementation of the **docopt** language will read your
spec and generate an argument parser based on it. The parser will then
process the command line and return a dictionary with the results.

Pioneered by [Vladimir Keleshev](https://twitter.com/keleshev) in 2012 for
Python, the idea caught on rather quickly and contributors started making
**docopt** available for other programming languages as well. There are now
many implementations available in languages including C, Go, Java, Ruby,
CoffeScript, Rust, and PHP. See the complete list of all the officially
supported ports on [Github](https://github.com/docopt).

## The language

The language itself is a _formalised_ version of the common help messages
as you may know them from existing applications. Despite its simplicity, the
syntax very powerful with all the features you might expect from a reasonable
argument parser. It supports subcommands, options and positional arguments. Any
of these can be made either optional or mandatory, and also mutually exclusive
with other options or arguments. Option arguments can have default values
assigned. And it is also possible to have a variable number of positional
arguments, e.g., zero or more of them. Here's an example of a program
description using **docopt**:

{% highlight text %}
Build and release software packages.

Usage:
  pkg add <repository> [--branch=<b>]
  pkg build <name>... [--force] [--env=<env>]
  pkg push <name> [<suite>] [--force]
  pkg clean (builds|cache)
  pkg -h | --help
  pkg --version

Options:
  -h, --help        Print this.
  -b, --branch=<b>  Git branch name [default: master].
  -f, --force       Perform the operation despite warnings.
  -e, --env=<e>     Select build environment [default: wheezy].
{% endhighlight %}

The syntax is almost identical with the help descriptions generated by Ruby's
`OptionParser` or Python's `ArgumentParser`.

## Parsing the command line

Now that the description is ready, how do we get from that to actually
processing the arguments of your program? You'll be pleased to hear that this
step is even simpler. The API consists of a **single function** that expects to
receive the command-line string and returns a dictionary with all the options
and arguments. It may differ slightly between implementations though.

I've tried the Python, Ruby and CoffeScript/JS versions and they worked really
well. Using the same options description in all of them wasn't a problem at
all. A few pointers and an example of how it works in each of the languages
follow.

### Python

**docopt** is available as a [package](https://pypi.python.org/pypi/docopt) in
the Python Package Index, so you can install it using the following command:

{% highlight bash %}
sudo pip install docopt
{% endhighlight %}

[PEP 257](https://www.python.org/dev/peps/pep-0257/) recommends that the
docstring of a script corresponds with its 'usage' message. We'll put the
**docopt** spec in there, right at the beginning of the script and refer to
it through the `__doc__` special variable. The `docopt` function will read
`sys.argv` and parse it. If we pass the version of our program to the function
as wel, it will create the `--version` option automatically.

{% highlight python %}
#!/usr/bin/env python

"""
Example program.

Usage:
  example command [<cmd_arg>]...
  example [-br] -p=<opt_arg> <argument>
  example -h | --help
  example --version

 Options:
   -h, --help       Show this message.
   -b, --beer       Drink beer.
   -r, --rock       Play AC/DC.
   -p, --pub=<p>    Which pub.
   --version        Print the version.
"""

from docopt import docopt
from pprint import pprint

if __name__ == '__main__':
    arguments = docopt(__doc__, version='FIXME')
    pprint(arguments)
{% endhighlight %}

### Ruby

Likewise for Ruby, there is a [docopt gem](https://rubygems.org/gems/docopt).
Use the following command to install it:

{% highlight bash %}
sudo gem install docopt
{% endhighlight %}

The interface in Ruby is much the same as in Python.

{% highlight ruby %}
#!/usr/bin/env ruby

require 'docopt'
require 'pp'

doc = <<DOCOPT
Example program.

Usage:
  example command [<cmd_arg>]...
  example [-br] -p=<opt_arg> <argument>
  example -h | --help
  example --version

 Options:
   -h, --help       Show this message.
   -b, --beer       Drink beer.
   -r, --rock       Play AC/DC.
   -p, --pub=<p>    Which pub.
   --version        Print the version.
DOCOPT

begin
  pp Docopt::docopt(doc, version: '1.2.3')
rescue Docopt::Exit => e
  puts e.message
end
{% endhighlight %}

### CoffeeScript

You can use [npm](https://www.npmjs.com/) to get **docopt** for Coffee/JS.
The following command will install it globally on your system:

{% highlight bash %}
sudo npm install -g docopt
{% endhighlight %}

And again, the interface is almost identical with the

{% highlight coffee %}
doc = """
Example program.

Usage:
  example command [<cmd_arg>]...
  example [-br] -p=<opt_arg> <argument>
  example -h | --help
  example --version

 Options:
   -h, --help       Show this message.
   -b, --beer       Drink beer.
   -r, --rock       Play AC/DC.
   -p, --pub=<p>    Which pub.
   --version        Print the version.
"""
{docopt} = require 'docopt'

console.log docopt(doc, version: '1.2.3')
{% endhighlight %}

## Summary

Docopt is a delightful way of describing command line interfaces. It means that
you can skip the ritual copy-pasting and docs searching to put together the
option parser before you get to the interesting bit. Was that `add_argument()`
or `addArgument()`? Who remembers these things?

**docopt** is free, open-source, and available for many languages. Check it
out on [Github](https://github.com/docopt).
